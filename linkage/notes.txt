***********
Terminologies
***********

1. Translation unit is the input to the compiler, and is generated by the preprocessor
-> its the result of source file, along with all the header declaration and macros expanded

2. linkage is a process that controls whether an interface is public or private, and determines whether any two identifiers refers to the same entity
-> namely internal, external and no linkage


>>>>>>>>>>>>>>
Example with the header file as `linkage_header.h` and implementation source file as `linkage_header.c`
>>>>>>>>>>>>>
>> To demonstrate external linkage using `extern_external_linkage.c`:

-> ** to get the translation unit:
$> gcc extern_external_linkage.c -E -o extern_external_linkage.i

-> ** to run the file: 
****  needs to be linked with the implementation file `linkage_header.c` to work
$> ...desktop/learning-c/linkage$ ../run.sh -f extern_external_linkage.c -l linkage_header.c

-> so this forms a translation unit between the header (linkage_header.h), implementation source (linkage_header.c), and its own source file (extern_external_linkage.c)
-> any .c files linked can access the variables with external linkage, and so can this file itself (extern_external_linkage.c) access variables that have external linkage on the other linked files
-> however, static files declared in this file (extern_external_linkage.c) are not accessable, and are private from the other linked files

-> this file displays the use of extern variables



>> To demonstrate internal linkage using `static_internal_linkage.c`:

-> to get the translation unit:
$> gcc static_internal_linkage.c -E -o static_internal_linkage.i

-> ** to run the file: 
****  needs to be linked with the implementation file `linkage_header.c` to work
 $> ...desktop/learning-c/linkage$ ../run.sh -f static_internal_linkage.c -l linkage_header.c

-> the same logic about the translation unit applies to this file too
-> this file just displays the use of static variables